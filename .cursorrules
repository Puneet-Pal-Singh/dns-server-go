Must follow guidelines

### **Cursor Coding Principles** ğŸš€  

These principles ensure **idiomatic, maintainable, and scalable** Go code while **minimizing redundancy and complexity**.  

---  

## **1ï¸âƒ£ General Rules**  
- **Think step-by-step before coding** â€“ Plan structure and logic first to avoid rewrites.  
- **Follow SOLID principles** â€“ Prioritize **Single Responsibility, Open-Closed, and Dependency Injection**.  
- **Code must be idiomatic Go** â€“ Follow Go conventions, avoid unnecessary abstractions.  
- **DRY (Don't Repeat Yourself)** â€“ Extract reusable logic into helper functions or shared components.  
- **KISS (Keep It Simple, Stupid)** â€“ Avoid over-engineering and unnecessary complexity.  
- **YAGNI (You Ainâ€™t Gonna Need It)** â€“ Donâ€™t add unused abstractions or premature optimizations.  
- **Every function should have a single responsibility** â€“ Small, modular functions make debugging and testing easier.  
- **Avoid deep nesting** â€“ Use early returns and keep logic flat for better readability.  
- **Minimize changes to core logic** â€“ Future features should integrate smoothly without modifying existing foundational files.  
- **Code should be self-documenting** â€“ Use meaningful variable names and minimal but clear comments.  

---  

## **2ï¸âƒ£ Backend / Go-Specific Rules**  
- **Use Goâ€™s concurrency correctly** â€“ Avoid race conditions, handle Goroutines safely.  
- **Memory efficiency matters** â€“ Optimize struct layouts and avoid excessive allocations.  
- **Use Dependency Injection** â€“ Pass dependencies instead of hardcoding them.  
- **Use interfaces for abstraction**, not unnecessary struct inheritance.  
- **Leverage Goâ€™s standard library first** â€“ Only use third-party libraries when necessary.  
- **Error handling must be clean** â€“ No silent failures; always log critical errors.  
- **Follow Go idioms for structuring projects** â€“ Use `pkg`, `cmd`, and `internal` wisely.  
- **Explain complex logic briefly** â€“ Use short, meaningful comments for non-trivial implementations.  
- **No TODOs in critical code** â€“ If something is unfinished, document it properly.  
- **Testing mindset** â€“ Ensure components are testable and avoid fragile dependencies.  

---  

## **3ï¸âƒ£ Scalability & Maintainability**  
- **Open-Closed Principle** â€“ New features should be **added without modifying existing logic**.  
- **High Cohesion, Loose Coupling** â€“ Keep related logic together while minimizing dependencies.  
- **Separation of Concerns** â€“ Different modules should handle distinct concerns.  
- **Logs and monitoring** â€“ Every critical function should have structured logging.  
- **Implement proper error handling** â€“ Use structured errors and avoid `panic`.  
- **Input validation matters** â€“ Validate inputs, especially in backend services.  
- **No unnecessary global state** â€“ Use explicit dependency injection where possible.  
- **Minimize external dependencies** â€“ Stick to built-in Go features unless necessary.  
- **Write scalable functions** â€“ Avoid hardcoded limits; allow for future flexibility.  
- **Avoid premature optimization** â€“ Write clean, correct code first, optimize later.  

---  

Project rule for our DNS server
- Take inspiration from - https://github.dev/miekg/dns 
- This repo contains many things to learn from.

---
<!-- 
This ensures **high-quality, maintainable, and scalable** Go code while **keeping it idiomatic and efficient**. âœ…   -->


<!-- Would you like any refinements or additions? ğŸš€ -->